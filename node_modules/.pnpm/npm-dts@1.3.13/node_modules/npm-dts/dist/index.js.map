{"version":3,"file":"index.js","mappings":"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","sources":["webpack://npm-dts/webpack/universalModuleDefinition","webpack://npm-dts/./lib/cli.ts","webpack://npm-dts/./lib/generator.ts","webpack://npm-dts/./lib/log.ts","webpack://npm-dts/external commonjs \"args\"","webpack://npm-dts/external commonjs \"mkdirp\"","webpack://npm-dts/external commonjs \"npm-run\"","webpack://npm-dts/external commonjs \"rimraf\"","webpack://npm-dts/external commonjs \"tmp\"","webpack://npm-dts/external commonjs \"winston\"","webpack://npm-dts/external node-commonjs \"fs\"","webpack://npm-dts/external node-commonjs \"path\"","webpack://npm-dts/webpack/bootstrap","webpack://npm-dts/./index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, () => {\nreturn ","import * as args from 'args'\nimport * as path from 'path'\nimport {ELogLevel} from './log'\n\n/**\n * CLI argument names\n */\nexport enum ECliArgument {\n  /**\n   * Main file of non-bundled package source\n   */\n  entry = 'entry',\n\n  /**\n   * Root directory of targeted package\n   */\n  root = 'root',\n\n  /**\n   * Temporary directory required during generation\n   */\n  tmp = 'tmp',\n\n  /**\n   * Additional TSC properties\n   */\n  tsc = 'tsc',\n\n  /**\n   * Selected logging level\n   */\n  logLevel = 'logLevel',\n\n  /**\n   * Output file path (relative to root)\n   */\n  output = 'output',\n\n  /**\n   * Flag which forces using own TSC as opposed to target TSC\n   * This should only be used for testing npm-dts itself\n   * This is because it generates incorrect module names\n   */\n  testMode = 'testMode',\n\n  /**\n   * Flag which forces attempting generation at least partially despite errors\n   */\n  force = 'force',\n}\n\n/**\n * Configuration structure for generating an aggregated dts file\n */\nexport interface INpmDtsArgs {\n  /**\n   * Iterator\n   */\n  [argName: string]: string | boolean\n\n  /**\n   * Main file of non-bundled package source. Can be a path relative to TSC rootDir.\n   */\n  entry?: string\n\n  /**\n   * Root directory of targeted package\n   */\n  root?: string\n\n  /**\n   * Temporary directory required during generation\n   */\n  tmp?: string\n\n  /**\n   * Additional TSC properties\n   */\n  tsc?: string\n\n  /**\n   * Selected logging level\n   */\n  logLevel?: ELogLevel\n\n  /**\n   * Attempts to at least partially generate typings ignoring non-critical errors\n   */\n  force?: boolean\n\n  /**\n   * Output file path (relative to root)\n   */\n  output?: string\n\n  /**\n   * Flag which forces using own TSC as opposed to target TSC\n   * This should only be used for testing npm-dts itself\n   * This is because it generates incorrect module names\n   */\n  testMode?: boolean\n}\n\n/**\n * CLI usage logic\n */\nexport class Cli {\n  /**\n   * Stores whether module was successfully launched\n   */\n  protected launched = false\n\n  /**\n   * Stores whether TMP directory location was passed\n   */\n  protected tmpPassed = false\n\n  /**\n   * Stores current CLI argument values\n   */\n  private args: INpmDtsArgs = {\n    entry: 'index.ts',\n    root: path.resolve(process.cwd()),\n    tmp: '<TEMP>',\n    tsc: '',\n    logLevel: ELogLevel.info,\n    force: false,\n    output: 'index.d.ts',\n    testMode: false,\n  }\n\n  /**\n   * Automatically reads CLI arguments and performs actions based on them\n   */\n  public constructor(injectedArguments?: INpmDtsArgs) {\n    if (injectedArguments) {\n      this.launched = true\n      this.storeArguments(injectedArguments)\n    } else {\n      args\n        .option(\n          ['e', 'entry'],\n          'Entry/main package file before bundling, relative to project root',\n        )\n        .option(\n          ['r', 'root'],\n          'NPM package directory containing package.json',\n          this.args.root,\n        )\n        .option(\n          ['t', 'tmp'],\n          'Directory for storing temporary information',\n          this.args.tmp,\n          (value: string) => {\n            if (!value.includes('<')) {\n              this.tmpPassed = true\n            }\n\n            return value\n          },\n        )\n        .option(\n          ['c', 'tsc'],\n          'Passed through non-validated additional TSC options',\n          this.args.tsc,\n        )\n        .option(\n          ['L', 'logLevel'],\n          'Log level (error, warn, info, verbose, debug)',\n          this.args.logLevel,\n        )\n        .option(\n          ['f', 'force'],\n          'Ignores non-critical errors and attempts to at least partially generate typings',\n          this.args.force,\n        )\n        .option(\n          ['o', 'output'],\n          'Overrides recommended output target to a custom one',\n          this.args.output,\n        )\n        .option(\n          ['m', 'testMode'],\n          'Configures npm-dts for self-test',\n          this.args.testMode,\n        )\n        .command('generate', 'Start generation', (name, sub, options) => {\n          this.launched = true\n          this.storeArguments(options)\n        })\n        .example(\n          'npm-dts generate',\n          'Generates index.d.ts file and updates package.json for CWD.',\n        )\n        .example(\n          'npm-dts -r /your/project/path generate',\n          'Performs generation on a custom path.',\n        )\n\n      args.parse(process.argv, {\n        name: 'npm-dts',\n        mri: {},\n        mainColor: 'yellow',\n        subColor: 'dim',\n      })\n\n      if (!this.launched) {\n        args.showHelp()\n      }\n    }\n  }\n\n  /**\n   * Gathers current value of a particular CLI argument\n   * @param arg argument name\n   */\n  protected getArgument(arg: ECliArgument) {\n    return this.args[arg]\n  }\n\n  /**\n   * Dynamically overrides value of stored argument\n   * @param arg argument name\n   * @param value argument value\n   */\n  protected setArgument(arg: ECliArgument, value: string | boolean) {\n    // @ts-ignore\n    this.args[arg] = value\n  }\n\n  /**\n   * Stores entered CLI arguments\n   * @param passedArguments arguments entered to CLI\n   */\n  private storeArguments(passedArguments: any = this.args) {\n    for (const argName of Object.keys(this.args)) {\n      this.args[argName] = Object.is(passedArguments[argName], undefined)\n        ? this.args[argName]\n        : passedArguments[argName]\n    }\n  }\n}\n","import {readdirSync, statSync, writeFileSync} from 'fs'\nimport {readFileSync} from 'fs'\nimport {mkdirp as mkdir} from 'mkdirp'\nimport * as npmRun from 'npm-run'\nimport {join, relative, resolve, dirname} from 'path'\nimport {rimraf as rm} from 'rimraf'\nimport * as tmp from 'tmp'\nimport {Cli, ECliArgument, INpmDtsArgs} from './cli'\nimport {debug, ELogLevel, error, info, init, verbose, warn} from './log'\nimport * as fs from 'fs'\n\nconst MKDIR_RETRIES = 5\n\n/**\n * Logic for generating aggregated typings for NPM module\n */\nexport class Generator extends Cli {\n  private packageInfo: any\n  private moduleNames: string[]\n  private throwErrors: boolean\n  private cacheContentEmptied: boolean = true\n\n  /**\n   * Auto-launches generation based on command line arguments\n   * @param injectedArguments generation arguments (same as CLI)\n   * @param enableLog enables logging when true, null allows application to decide\n   * @param throwErrors makes generation throw errors when true\n   */\n  public constructor(\n    injectedArguments?: INpmDtsArgs,\n    enableLog: boolean | null = null,\n    throwErrors = false,\n  ) {\n    super(injectedArguments)\n\n    this.throwErrors = throwErrors\n\n    if (enableLog === null) {\n      enableLog = !injectedArguments\n    }\n\n    if (enableLog) {\n      init('npm-dts', this.getLogLevel())\n\n      const myPackageJson = JSON.parse(\n        readFileSync(resolve(__dirname, '..', 'package.json'), {\n          encoding: 'utf8',\n        }),\n      )\n\n      const soft = `          npm-dts v${myPackageJson.version}                `\n      let author = '          by Vytenis Urbonavičius                          '\n      let spaces = '                                                           '\n      let border = '___________________________________________________________'\n\n      author = author.substring(0, soft.length)\n      spaces = spaces.substring(0, soft.length)\n      border = border.substring(0, soft.length)\n\n      info(` ${border} `)\n      info(`|${spaces}|`)\n      info(`|${spaces}|`)\n      info(`|${soft}|`)\n      info(`|${author}|`)\n      info(`|${spaces}|`)\n      info(`|${border}|`)\n      info(` ${spaces} `)\n    }\n  }\n\n  /**\n   * Executes generation of an aggregated dts file\n   */\n  public async generate() {\n    info(`Generating declarations for \"${this.getRoot()}\"...`)\n\n    let hasError = false\n    let exception = null\n    const cleanupTasks: (() => void)[] = []\n\n    if (!this.tmpPassed) {\n      verbose('Locating OS Temporary Directory...')\n\n      try {\n        await new Promise<void>(done => {\n          tmp.dir((tmpErr, tmpDir, rmTmp) => {\n            if (tmpErr) {\n              error('Could not create OS Temporary Directory!')\n              this.showDebugError(tmpErr)\n              throw tmpErr\n            }\n\n            verbose('OS Temporary Directory was located!')\n            this.setArgument(ECliArgument.tmp, resolve(tmpDir, 'npm-dts'))\n\n            cleanupTasks.push(() => {\n              verbose('Deleting OS Temporary Directory...')\n              rmTmp()\n              verbose('OS Temporary Directory was deleted!')\n            })\n            done()\n          })\n        })\n      } catch (e) {\n        hasError = true\n        exception = e\n      }\n    }\n\n    if (!hasError) {\n      await this._generate().catch(async e => {\n        hasError = true\n\n        const output = this.getOutput()\n\n        error(`Generation of ${output} has failed!`)\n        this.showDebugError(e)\n\n        if (!this.useForce()) {\n          if (this.getLogLevel() === ELogLevel.debug) {\n            info(\n              'If issue is not severe, you can try forcing execution using force flag.',\n            )\n            info(\n              'In case of command line usage, add \"-f\" as the first parameter.',\n            )\n          } else {\n            info('You should try running npm-dts with debug level logging.')\n            info(\n              'In case of command line, debug mode is enabled using \"-L debug\".',\n            )\n          }\n        }\n\n        if (!this.cacheContentEmptied) {\n          await this.clearTempDir()\n        }\n\n        exception = e\n      })\n    }\n\n    cleanupTasks.forEach(task => task())\n\n    if (!hasError) {\n      info('Generation is completed!')\n    } else {\n      error('Generation failed!')\n\n      if (this.throwErrors) {\n        throw exception || new Error('Generation failed!')\n      }\n    }\n  }\n\n  /**\n   * Logs serialized error if it exists\n   * @param e - error to be shown\n   */\n  private showDebugError(e: any) {\n    if (e) {\n      if (e.stdout) {\n        debug(`Error: \\n${e.stdout.toString()}`)\n      } else {\n        debug(`Error: \\n${JSON.stringify(e)}`)\n      }\n    }\n  }\n\n  /**\n   * Launches generation of typings\n   */\n  private async _generate() {\n    await this.generateTypings()\n    let source = await this.combineTypings()\n    source = this.addAlias(source)\n    await this.storeResult(source)\n  }\n\n  private getLogLevel(): ELogLevel {\n    const logLevel = this.getArgument(ECliArgument.logLevel) as ELogLevel\n    return ELogLevel[logLevel] ? logLevel : ELogLevel.info\n  }\n\n  /**\n   * Gathers entry file address (relative to project root path)\n   */\n  private getEntry(): string {\n    return this.getArgument(ECliArgument.entry) as string\n  }\n\n  /**\n   * Gathers target project root path\n   */\n  private getRoot(): string {\n    return resolve(this.getArgument(ECliArgument.root) as string)\n  }\n\n  /**\n   * Gathers TMP directory to be used for TSC operations\n   */\n  private getTempDir(): string {\n    return resolve(this.getArgument(ECliArgument.tmp) as string)\n  }\n\n  /**\n   * Gathers output path to be used (relative to root)\n   */\n  private getOutput(): string {\n    return this.getArgument(ECliArgument.output) as string\n  }\n\n  /**\n   * Checks if script is forced to use its built-in TSC\n   */\n  private useTestMode(): boolean {\n    return this.getArgument(ECliArgument.testMode) as boolean\n  }\n\n  /**\n   * Checks if script is forced to attempt generation despite errors\n   */\n  private useForce(): boolean {\n    return this.getArgument(ECliArgument.force) as boolean\n  }\n\n  /**\n   * Creates TMP directory to be used for TSC operations\n   * @param retries amount of times to retry on failure\n   */\n  private makeTempDir(retries = MKDIR_RETRIES): Promise<void> {\n    const tmpDir = this.getTempDir()\n    verbose('Preparing \"tmp\" directory...')\n\n    return new Promise((done, fail) => {\n      mkdir(tmpDir)\n        .then(() => {\n          this.cacheContentEmptied = false\n          verbose('\"tmp\" directory was prepared!')\n          done()\n        })\n        .catch(mkdirError => {\n          error(`Failed to create \"${tmpDir}\"!`)\n          this.showDebugError(mkdirError)\n\n          if (retries) {\n            const sleepTime = 100\n            verbose(`Will retry in ${sleepTime}ms...`)\n\n            setTimeout(() => {\n              this.makeTempDir(retries - 1).then(done, fail)\n            }, sleepTime)\n          } else {\n            error(`Stopped trying after ${MKDIR_RETRIES} retries!`)\n            fail()\n          }\n        })\n    })\n  }\n\n  /**\n   * Removes TMP directory\n   */\n  private clearTempDir() {\n    const tmpDir = this.getTempDir()\n    verbose('Cleaning up \"tmp\" directory...')\n\n    return new Promise<void>((done, fail) => {\n      rm(tmpDir)\n        .then(() => {\n          this.cacheContentEmptied = true\n          verbose('\"tmp\" directory was cleaned!')\n          done()\n        })\n        .catch(rmError => {\n          error(`Could not clean up \"tmp\" directory at \"${tmpDir}\"!`)\n          this.showDebugError(rmError)\n          fail()\n        })\n    })\n  }\n\n  /**\n   * Re-creates empty TMP directory to be used for TSC operations\n   */\n  private resetCacheDir() {\n    verbose('Will now reset \"tmp\" directory...')\n    return new Promise((done, fail) => {\n      this.clearTempDir().then(() => {\n        this.makeTempDir().then(done, fail)\n      }, fail)\n    })\n  }\n\n  /**\n   * Generates per-file typings using TSC\n   */\n  private async generateTypings() {\n    await this.resetCacheDir()\n\n    verbose('Generating per-file typings using TSC...')\n\n    const tscOptions = this.getArgument(ECliArgument.tsc) as string\n\n    const cmd =\n      'tsc --declaration --emitDeclarationOnly --declarationDir \"' +\n      this.getTempDir() +\n      '\"' +\n      (tscOptions.length ? ` ${tscOptions}` : '')\n\n    debug(cmd)\n\n    try {\n      npmRun.execSync(\n        cmd,\n        {\n          cwd: this.useTestMode() ? resolve(__dirname, '..') : this.getRoot(),\n        },\n        (err: any, stdout: any, stderr: any) => {\n          if (err) {\n            if (this.useForce()) {\n              warn('TSC exited with errors!')\n            } else {\n              error('TSC exited with errors!')\n            }\n\n            this.showDebugError(err)\n          } else {\n            if (stdout) {\n              process.stdout.write(stdout)\n            }\n\n            if (stderr) {\n              process.stderr.write(stderr)\n            }\n          }\n        },\n      )\n    } catch (e) {\n      if (this.useForce()) {\n        warn('Suppressing errors due to \"force\" flag!')\n        this.showDebugError(e)\n        warn('Generated declaration files might not be valid!')\n      } else {\n        throw e\n      }\n    }\n\n    verbose('Per-file typings have been generated using TSC!')\n  }\n\n  /**\n   * Gathers a list of created per-file declaration files\n   * @param dir directory to be scanned for files (called during recursion)\n   * @param files discovered array of files (called during recursion)\n   */\n  private getDeclarationFiles(\n    dir: string = this.getTempDir(),\n    files: string[] = [],\n  ) {\n    if (dir === this.getTempDir()) {\n      verbose('Loading list of generated typing files...')\n    }\n\n    try {\n      readdirSync(dir).forEach(file => {\n        if (statSync(join(dir, file)).isDirectory()) {\n          files = this.getDeclarationFiles(join(dir, file), files)\n        } else {\n          files = files.concat(join(dir, file))\n        }\n      })\n    } catch (e) {\n      error('Failed to load list of generated typing files...')\n      this.showDebugError(e)\n      throw e\n    }\n\n    if (dir === this.getTempDir()) {\n      verbose('Successfully loaded list of generated typing files!')\n    }\n\n    return files\n  }\n\n  /**\n   * Loads package.json information of target project\n   */\n  private getPackageDetails() {\n    if (this.packageInfo) {\n      return this.packageInfo\n    }\n\n    verbose('Loading package.json...')\n\n    const root = this.getRoot()\n    const packageJsonPath = resolve(root, 'package.json')\n\n    try {\n      this.packageInfo = JSON.parse(\n        readFileSync(packageJsonPath, {encoding: 'utf8'}),\n      )\n    } catch (e) {\n      error(`Failed to read package.json at \"'${packageJsonPath}'\"`)\n      this.showDebugError(e)\n      throw e\n    }\n\n    verbose('package.json information has been loaded!')\n    return this.packageInfo\n  }\n\n  /**\n   * Generates module name based on file path\n   * @param path path to be converted to module name\n   * @param options additional conversion options\n   */\n  private convertPathToModule(\n    path: string,\n    options: IConvertPathToModuleOptions = {},\n  ) {\n    const {\n      rootType = IBasePathType.tmp,\n      noPrefix = false,\n      noExtensionRemoval = false,\n      noExistenceCheck = false,\n    } = options\n\n    const packageDetails = this.getPackageDetails()\n\n    const fileExisted =\n      noExistenceCheck ||\n      (!noExtensionRemoval &&\n        fs.existsSync(path) &&\n        fs.lstatSync(path).isFile())\n\n    if (rootType === IBasePathType.cwd) {\n      path = relative(process.cwd(), path)\n    } else if (rootType === IBasePathType.root) {\n      path = relative(this.getRoot(), path)\n    } else if (rootType === IBasePathType.tmp) {\n      path = relative(this.getTempDir(), path)\n    }\n\n    if (!noPrefix) {\n      path = `${packageDetails.name}/${path}`\n    }\n\n    path = path.replace(/\\\\/g, '/')\n\n    if (fileExisted && !noExtensionRemoval) {\n      path = path.replace(/\\.[^.]+$/g, '')\n      path = path.replace(/\\.d$/g, '')\n    }\n\n    return path\n  }\n\n  /**\n   * Loads generated per-file declaration files\n   */\n  private loadTypings() {\n    const result: IDeclarationMap = {}\n\n    const declarationFiles = this.getDeclarationFiles()\n\n    verbose('Loading declaration files and mapping to modules...')\n    declarationFiles.forEach(file => {\n      const moduleName = this.convertPathToModule(file)\n\n      try {\n        result[moduleName] = readFileSync(file, {encoding: 'utf8'})\n      } catch (e) {\n        error(`Could not load declaration file '${file}'!`)\n        this.showDebugError(e)\n        throw e\n      }\n    })\n\n    verbose('Loaded declaration files and mapped to modules!')\n    return result\n  }\n\n  private resolveImportSourcesAtLine(\n    regexp: RegExp,\n    line: string,\n    moduleName: string,\n  ) {\n    const matches = line.match(regexp)\n\n    if (matches && matches[2].startsWith('.')) {\n      const relativePath = `../${matches[2]}`\n\n      let resolvedModule = resolve(moduleName, relativePath)\n\n      resolvedModule = this.convertPathToModule(resolvedModule, {\n        rootType: IBasePathType.cwd,\n        noPrefix: true,\n        noExtensionRemoval: true,\n      })\n\n      if (!this.moduleExists(resolvedModule)) {\n        resolvedModule += '/index'\n      }\n\n      line = line.replace(regexp, `$1${resolvedModule}$3`)\n    }\n\n    return line\n  }\n\n  /**\n   * Alters import sources to avoid relative addresses and default index usage\n   * @param source import source to be resolved\n   * @param moduleName name of module containing import\n   */\n  private resolveImportSources(source: string, moduleName: string) {\n    source = source.replace(/\\r\\n/g, '\\n')\n    source = source.replace(/\\n\\r/g, '\\n')\n    source = source.replace(/\\r/g, '\\n')\n\n    let lines = source.split('\\n')\n\n    lines = lines.map(line => {\n      line = this.resolveImportSourcesAtLine(\n        /(from ['\"])([^'\"]+)(['\"])/,\n        line,\n        moduleName,\n      )\n\n      line = this.resolveImportSourcesAtLine(\n        /(import\\(['\"])([^'\"]+)(['\"]\\))/,\n        line,\n        moduleName,\n      )\n\n      return line\n    })\n\n    source = lines.join('\\n')\n\n    return source\n  }\n\n  /**\n   * Combines typings into a single declaration source\n   */\n  private async combineTypings() {\n    const typings = this.loadTypings()\n    await this.clearTempDir()\n\n    this.moduleNames = Object.keys(typings)\n\n    verbose('Combining typings into single file...')\n\n    const sourceParts: string[] = []\n\n    Object.entries(typings).forEach(([moduleName, fileSource]) => {\n      fileSource = fileSource.replace(/declare /g, '')\n      fileSource = this.resolveImportSources(fileSource, moduleName)\n      sourceParts.push(\n        `declare module '${moduleName}' {\\n${(fileSource as string).replace(\n          /^./gm,\n          '  $&',\n        )}\\n}`,\n      )\n    })\n\n    verbose('Combined typings into a single file!')\n    return sourceParts.join('\\n')\n  }\n\n  /**\n   * Verifies if module specified exists among known modules\n   * @param moduleName name of module to be checked\n   */\n  private moduleExists(moduleName: string) {\n    return this.moduleNames.includes(moduleName)\n  }\n\n  /**\n   * Adds alias for main NPM package file to generated .d.ts source\n   * @param source generated .d.ts declaration source so far\n   */\n  private addAlias(source: string) {\n    verbose('Adding alias for main file of the package...')\n\n    const packageDetails = this.getPackageDetails()\n    const entry = this.getEntry()\n\n    if (!entry) {\n      error('No entry file is available!')\n      throw new Error('No entry file is available!')\n    }\n\n    const mainFile = this.convertPathToModule(resolve(this.getRoot(), entry), {\n      rootType: IBasePathType.root,\n      noExistenceCheck: true,\n    })\n\n    source +=\n      `\\ndeclare module '${packageDetails.name}' {\\n` +\n      `  import main = require('${mainFile}');\\n` +\n      '  export = main;\\n' +\n      '}'\n\n    verbose('Successfully created alias for main file!')\n\n    return source\n  }\n\n  /**\n   * Stores generated .d.ts declaration source into file\n   * @param source generated .d.ts source\n   */\n  private async storeResult(source: string) {\n    const output = this.getOutput()\n    const root = this.getRoot()\n    const file = resolve(root, output)\n    const folderPath = dirname(file)\n\n    verbose('Ensuring that output folder exists...')\n    debug(`Creating output folder: \"${folderPath}\"...`)\n\n    try {\n      await mkdir(folderPath)\n    } catch (mkdirError) {\n      error(`Failed to create \"${folderPath}\"!`)\n      this.showDebugError(mkdirError)\n      throw mkdirError\n    }\n\n    verbose('Output folder is ready!')\n    verbose(`Storing typings into ${output} file...`)\n\n    try {\n      writeFileSync(file, source, {encoding: 'utf8'})\n    } catch (e) {\n      error(`Failed to create ${output}!`)\n      this.showDebugError(e)\n      throw e\n    }\n\n    verbose(`Successfully created ${output} file!`)\n  }\n}\n\n/**\n * Map of modules and their declarations\n */\nexport interface IDeclarationMap {\n  [moduleNames: string]: string\n}\n\n/**\n * Types of base path used during path resolving\n */\nexport enum IBasePathType {\n  /**\n   * Base path is root of targeted project\n   */\n  root = 'root',\n\n  /**\n   * Base path is tmp directory\n   */\n  tmp = 'tmp',\n\n  /**\n   * Base path is CWD\n   */\n  cwd = 'cwd',\n}\n\n/**\n * Additional conversion options\n */\nexport interface IConvertPathToModuleOptions {\n  /**\n   * Type of base path used during path resolving\n   */\n  rootType?: IBasePathType\n\n  /**\n   * Disables addition of module name as prefix for module name\n   */\n  noPrefix?: boolean\n\n  /**\n   * Disables extension removal\n   */\n  noExtensionRemoval?: boolean\n\n  /**\n   * Disables existence check and assumes that file exists\n   */\n  noExistenceCheck?: boolean\n}\n","import * as winston from 'winston'\nimport {\n  debug as winstonDebug,\n  error as winstonError,\n  info as winstonInfo,\n  silly as winstonSilly,\n  verbose as winstonVerbose,\n  warn as winstonWarn,\n} from 'winston'\n\nwinston.addColors({\n  error: 'red',\n  warn: 'yellow',\n  info: 'cyan',\n  debug: 'green',\n})\n\nlet logEnabled = false\n\n/**\n * Supported debug levels\n */\nexport enum ELogLevel {\n  /**\n   * Error\n   */\n  error = 'error',\n\n  /**\n   * Warning\n   */\n  warn = 'warn',\n\n  /**\n   * Information\n   */\n  info = 'info',\n\n  /**\n   * Verbose information\n   */\n  verbose = 'verbose',\n\n  /**\n   * Debug information\n   */\n  debug = 'debug',\n}\n\n/**\n * Logs error message\n * @param message Message to be logged\n */\nexport const error = (message: string) => {\n  if (logEnabled) {\n    return winstonError(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Logs warning message\n * @param message Message to be logged\n */\nexport const warn = (message: string) => {\n  if (logEnabled) {\n    return winstonWarn(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Logs informational message\n * @param message Message to be logged\n */\nexport const info = (message: string) => {\n  if (logEnabled) {\n    return winstonInfo(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Logs verbose message\n * @param message Message to be logged\n */\nexport const verbose = (message: string) => {\n  if (logEnabled) {\n    return winstonVerbose(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Logs debug message\n * @param message Message to be logged\n */\nexport const debug = (message: string) => {\n  if (logEnabled) {\n    return winstonDebug(message)\n  } else {\n    return null\n  }\n}\n\n/**\n * Initializes and enables logging\n * @param label prefix to be used before each log line\n */\nexport const init = (label: string, level: ELogLevel) => {\n  winston.configure({\n    level,\n    format: winston.format.combine(\n      winston.format.colorize(),\n      winston.format.label({label}),\n      winston.format.timestamp(),\n      winston.format.prettyPrint(),\n      winston.format.printf(\n        (parts: any) => `[${parts.label}] [${parts.level}] : ${parts.message}`,\n      ),\n    ),\n    transports: [new winston.transports.Console()],\n  })\n\n  logEnabled = true\n}\n","module.exports = require(\"args\");","module.exports = require(\"mkdirp\");","module.exports = require(\"npm-run\");","module.exports = require(\"rimraf\");","module.exports = require(\"tmp\");","module.exports = require(\"winston\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export {Generator} from './lib/generator'\nexport {INpmDtsArgs} from './lib/cli'\nexport {ELogLevel} from './lib/log'\n"],"names":["root","factory","exports","module","define","amd","a","i","global","ECliArgument","injectedArguments","launched","tmpPassed","args","entry","path","resolve","process","cwd","tmp","tsc","logLevel","ELogLevel","info","force","output","testMode","this","storeArguments","option","value","includes","command","name","sub","options","example","parse","argv","mri","mainColor","subColor","showHelp","getArgument","arg","setArgument","passedArguments","Object","keys","argName","is","undefined","Cli","IBasePathType","enableLog","throwErrors","cacheContentEmptied","init","getLogLevel","myPackageJson","JSON","readFileSync","__dirname","encoding","soft","version","author","spaces","border","substring","length","generate","getRoot","hasError","exception","cleanupTasks","verbose","Promise","done","dir","tmpErr","tmpDir","rmTmp","error","showDebugError","push","_generate","catch","e","getOutput","useForce","debug","clearTempDir","forEach","task","Error","stdout","toString","stringify","generateTypings","combineTypings","source","addAlias","storeResult","getEntry","getTempDir","useTestMode","makeTempDir","retries","fail","then","mkdirError","setTimeout","rmError","resetCacheDir","tscOptions","cmd","npmRun","execSync","err","stderr","warn","write","getDeclarationFiles","files","readdirSync","file","statSync","join","isDirectory","concat","getPackageDetails","packageInfo","packageJsonPath","convertPathToModule","rootType","noPrefix","noExtensionRemoval","noExistenceCheck","packageDetails","fileExisted","fs","existsSync","lstatSync","isFile","relative","replace","loadTypings","result","declarationFiles","moduleName","resolveImportSourcesAtLine","regexp","line","matches","match","startsWith","relativePath","resolvedModule","moduleExists","resolveImportSources","lines","split","map","typings","moduleNames","sourceParts","entries","fileSource","mainFile","folderPath","dirname","writeFileSync","Generator","winston","addColors","logEnabled","message","label","level","configure","format","combine","colorize","timestamp","prettyPrint","printf","parts","transports","Console","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}